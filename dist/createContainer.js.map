{"version":3,"sources":["../src/createContainer.js"],"names":[],"mappings":";;;;;;;;kBAMe,UAAS,gBAAT,EAA2B,KAA3B,EAAkC;AAC/C,MAAI,MAAM,WAAN,KAAsB,QAAtB,EAAgC;AAClC,WAAO,IAAI,KAAJ,wCACH,iBAAiB,WAAjB,IAAgC,iBAAiB,IAAjB,4GAD7B,CAAP,CADkC;GAApC;;eAMkC,oCAAqB,aAAM,QAAN,EAArB,EAPa;;MAOvC,6BAPuC;;MAOzB,0DAPyB;;MAQzC;;;AAKJ,aALI,SAKJ,CAAY,KAAZ,EAAmB,OAAnB,EAA4B;4BALxB,WAKwB;;yEALxB,sBAMI,OAAO,UADa;;AAE1B,YAAK,KAAL,GAAa,MAAM,KAAN,IAAe,QAAQ,KAAR,CAFF;AAG1B,gBAAU,MAAK,KAAL,0EAEI,MAAK,WAAL,CAAiB,WAAjB,sHAE+B,MAAK,WAAL,CAAiB,WAAjB,OAJ7C,EAH0B;AAS1B,YAAK,KAAL,GAAa,MAAK,KAAL,CAAW,QAAX,EAAb;;AAT0B,WAW1B,CAAK,mBAAL,GAA2B,KAA3B,CAX0B;;AAa1B,YAAK,YAAL,GAAoB,MAAK,KAAL,CAAW,CAAX,CAClB,OADkB,CACV;eAAM,MAAK,KAAL,CAAW,GAAX,CAAe,oBAAQ,SAAR,CAAf;OAAN,CADU,CAElB,SAFkB,CAER,gBAAQ;AAChB,YAAI,CAAC,IAAD,EAAO;AACT,iBADS;SAAX;AAGA,YAAI,CAAC,mBAAD,EAAsB;AACxB,iBAAO,MAAK,KAAL,GAAa,IAAb,CADiB;SAA1B;AAGA,cAAK,QAAL,CAAc,IAAd,EAPgB;OAAR,CAFZ,CAb0B;;KAA5B;;iBALI;;0CA8BgB;AAClB,aAAK,mBAAL,GAA2B,IAA3B,CADkB;;;;6CAGG;;AAErB,aAAK,YAAL,CAAkB,WAAlB,GAFqB;;;;+BAId;AACP,eAAO,8BAAC,gBAAD,EAAsB,KAAK,KAAL,CAA7B,CADO;;;;WArCL;IAAkB,gBAAM,SAAN,EARuB;;AAQzC,YACG,eAAiB,iBAAiB,WAAjB,IAAgC,iBAAiB,IAAjB,mBATX;AAQzC,YAEG,eAAe;AACpB,WAAO,gBAAM,SAAN,CAAgB,UAAhB,eAAP;IAX2C;CAAlC","file":"createContainer.js","sourcesContent":["import React, { Component, PropTypes } from 'react'\nimport { Model } from 'falcor'\nimport { intentFactory } from './intentFactory'\nimport { store } from './store'\nimport { toPaths } from './utils'\n\nexport default function(WrappedComponent, optFn) {\n  if (optFn.constructor !== Function) {\n    return new Error(`second argument passed to\n      ${WrappedComponent.displayName || WrappedComponent.name}\n      must be a function, which returns fragments as a first argument,\n      following with intents`)\n  }\n  const { fragments, ...intents } = optFn(intentFactory, store.getModel())\n  class Container extends React.Component {\n    static displayName = `${WrappedComponent.displayName || WrappedComponent.name}Ez.Container`;\n    static contextTypes = {\n      model: React.PropTypes.instanceOf(Model)\n    }\n    constructor(props, context) {\n      super(props, context);\n      this.store = props.store || context.store\n      invariant(this.store,\n        `Could not find \"store\" in either the context or\n        props of \"${this.constructor.displayName}\".\n        Either wrap the root component in a <Provider>,\n        or explicitly pass \"store\" as a prop to \"${this.constructor.displayName}\".`\n      )\n      this.model = this.store.getModel()\n      // TODO consider using versions with getFragment\n      this.componentHasMounted = false\n\n      this.subscription = this.model.$.\n        flatMap(() => this.model.get(toPaths(fragments))).\n        subscribe(data => {\n          if (!data) {\n            return;\n          }\n          if (!componentHasMounted) {\n            return this.state = data\n          }\n          this.setState(data)\n        })\n    }\n    componentDidMount() {\n      this.componentHasMounted = true;\n    }\n    componentWillUnmount() {\n      // Clean-up subscription before un-mounting\n      this.subscription.unsubscribe();\n    }\n    render() {\n      return <WrappedComponent {...this.state} />\n    }\n  }\n}\n"]}